
import express = require('express');
import multer  = require('multer');
import path = require('path');
import fs = require('fs');
import mkdirp = require('mkdirp');
import archiver = require('archiver');
import async = require('async');

import config = require('./config');
import models = require('./models');
import { isFunction } from 'util';
import { fstat } from 'fs';

const upload = multer(config.multer);

const router = express.Router();

//TODO - what is this for?
var storage = multer.diskStorage({
    destination: function (req, file, cb) {
      cb(null, path.join(__dirname,'/uploads'))
    },
    filename: function (req, file, cb) {
      let fileExtension = file.originalname.split('.')[1]
      cb(null, file.fieldname + '-' + Date.now()+'.'+fileExtension)
    }
})

router.post('/session', (req, res, next)=>{
    req.body.status = "created";
    req.body.request_headers = req.headers;
    let session = new models.Session(req.body);
    session.save().then(_session=>{ //mongoose contains err on the 1st argument of resolve!? odd.
        res.json(_session);
    }).catch(err=>{
        next(err);
    });
});

router.get('/session/:session_id', (req, res, next) => {
    models.Session.findById(req.params.session_id).then(session=>{
        res.json(session);
    }).catch(err=>{
        next(err);
    });
});

/*
//deprecated by /download/:session_id/*
router.get('/session/:session_id/log', (req, res, next) => {
    models.Session.findById(req.params.session_id).then(session=>{
        res.setHeader("content-type", "text/plain");
        fs.createReadStream(config.workdir+"/"+session._id+"/preprocess.log").pipe(res);
    }).catch(err=>{
        next(err);
    });
});

//deprecated by /download/:session_id/*
router.get('/session/:session_id/error', (req, res, next) => {
    models.Session.findById(req.params.session_id).then(session=>{
        res.setHeader("content-type", "text/plain");
        fs.createReadStream(config.workdir+"/"+session._id+"/preprocess.err").pipe(res);
    }).catch(err=>{
        next(err);
    });
});

//deprecated by /download/:session_id/*
router.get('/session/:session_id/list', (req, res, next) => {
    models.Session.findById(req.params.session_id).then(session=>{
        res.setHeader("content-type", "text/plain");
        fs.createReadStream(config.workdir+"/"+session._id+"/list").pipe(res);
    }).catch(err=>{
        next(err);
    });
});

//deprecated by /download/:session_id/*
router.get('/session/:session_id/ezbids', (req, res, next) => {
    models.Session.findById(req.params.session_id).then(session=>{
        res.setHeader("content-type", "application/json");
        console.debug("loading ezbids.json from", config.workdir, session._id);
        fs.createReadStream(config.workdir+"/"+session._id+"/ezBIDS.json").pipe(res);
    }).catch(err=>{
        next(err);
    });
});
*/

router.post('/session/:session_id/finalize', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        if(!session) return next("no such session");
        fs.writeFile(config.workdir+"/"+session._id+"/finalized.json", JSON.stringify(req.body), err=>{
            models.ezBIDS.findOneAndUpdate({_session_id: req.params.session_id}, {$set: {
                updated: req.body, 
                update_date: new Date(),
            }}).then(err=>{
                session.status = "finalized";
                session.save().then(()=>{
                    res.send("ok"); 
                });
            });
        });
        /*
        //store finalized content disk
        req.pipe(fs.createWriteStream(config.workdir+"/"+session._id+"/finalized.json"));
        req.on('end', ()=>{
            session.status = "finalized";
            session.save().then(()=>{
                res.send("ok"); 
            });
        });
        */
    });
});

//let user download files within session (like the .png image generated by analyzer)
router.get('/download/:session_id/*', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        let basepath = config.workdir+"/"+session._id; 

        //validate path so it will be inside the basepath
        let fullpath = path.resolve(basepath+"/"+req.params[0]);
        if(!fullpath.startsWith(basepath)) return next("invalid path");

        //TODO - if requested path is a file, thenstream
        let stats = fs.lstatSync(fullpath);
        if(stats.isFile()) {
            res.setHeader('Content-disposition', 'attachment; filename='+path.basename(fullpath));
            fs.createReadStream(fullpath).pipe(res);
        } else if(stats.isDirectory()) {
            res.setHeader('Content-disposition', 'attachment; filename='+path.basename(fullpath)+".zip");
            const archive = archiver('zip', {
                zlib: { level: 9 }
            });
            archive.directory(fullpath, 'bids');
            archive.finalize();
            archive.pipe(res);
        } else next("unknown file");

        //TODO - if it's directory, then send an archive down

    }).catch(err=>{
        next(err);
    });
});

router.post('/upload/:session_id', upload.single('file'), (req:any, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        let src_path = req.file.path;
        let dirty_path = config.workdir+"/"+req.params.session_id+"/"+req.body.path;
        let dest_path = path.resolve(dirty_path);

        if(!dest_path.startsWith(config.workdir)) return next("invalid path");
        let destdir = path.dirname(dest_path);

        //move the file over to workdir
        mkdirp(destdir).then(err=>{
            fs.rename(src_path, dest_path, err=>{
                if(err) return next(err);
                res.send("ok");
            });
        });

    }).catch(err=>{
        console.error(err);
        next(err);
    });
});

router.post('/upload-multi/:session_id', upload.any(), (req:any, res, next)=>{
    models.Session.findById(req.params.session_id).then(async session=>{
        let idx = -1;
        async.eachSeries(req.files, (file, next_file)=>{
            idx++;
            let src_path = file.path;
            /* //file
11|ezbids- | {
11|ezbids- |   fieldname: 'files',
11|ezbids- |   originalname: 'i1848324.MRDC.82',
11|ezbids- |   encoding: '7bit',
11|ezbids- |   mimetype: 'application/octet-stream',
11|ezbids- |   destination: '/mnt/ezbids/upload',
11|ezbids- |   filename: '2d682c5694b0fb8da2beeea3e670350a',
11|ezbids- |   path: '/mnt/ezbids/upload/2d682c5694b0fb8da2beeea3e670350a',
11|ezbids- |   size: 147882
11|ezbids- | }
            */
            //let dirty_path = config.workdir+"/"+req.params.session_id+"/"+req.body.path;
            let dirty_path = config.workdir+"/"+req.params.session_id+"/"+req.body["paths"][idx];
            let dest_path = path.resolve(dirty_path);

            if(!dest_path.startsWith(config.workdir)) return next_file("invalid path:", dest_path);
            let destdir = path.dirname(dest_path);

            //move the file over to workdir
            mkdirp(destdir).then(err=>{
                console.log("renaming", src_path, dest_path);
                fs.rename(src_path, dest_path, err=>{
                    if(err) return next_file(err);
                    next_file();
                });
            });
        }, err=>{
            if(err) return next(err);
            res.send("ok");
        });

    }).catch(err=>{
        console.error(err);
        next(err);
    });
});


//done uploading.
router.patch('/session/uploaded/:session_id', (req, res, next)=>{
    models.Session.findByIdAndUpdate(req.params.session_id, {
        status: "uploaded", 
        status_msg: "Waiting in the queue..", 
        upload_finish_date: new Date()
    }).then(session=>{
        if(!session) return next("no such session");
        res.send("ok");
    }).catch(err=>{
        console.error(err);
        next(err);
    });
});

module.exports = router;

