import * as express from 'express';
import multer  from 'multer';
import path from 'path';
import fs from 'fs';
import mkdirp from 'mkdirp';
import archiver from 'archiver';
import async from 'async';

import * as models from './models';

const upload = multer({
    dest: process.env.UPLOAD_DIR,
});
if (!fs.existsSync(process.env.WORK_DIR)) {
    fs.mkdirSync(process.env.WORK_DIR);
}

const router = express.Router();

router.get('/health', (req, res, next) => {
    let status = "ok";
    let message = "";

    //check to see if we can access the workdir
    try {
        fs.writeFileSync(process.env.WORK_DIR + '/health.txt', "test")
    } catch (err) {
        status = "failed";
        message = err;
    }
    res.json({status, message, date: new Date()});
});

router.post('/session', (req, res, next)=>{
    req.body.status = "created";
    req.body.request_headers = req.headers;
    let session = new models.Session(req.body);
    session.save().then(_session=>{ //mongoose contains err on the 1st argument of resolve!? odd.
        res.json(_session);
    }).catch(err=>{
        next(err);
    });
});

router.get('/session/:session_id', (req, res, next) => {
    models.Session.findById(req.params.session_id).then(session=>{
        res.json(session);
    }).catch(err=>{
        next(err);
    });
});

router.post('/session/:session_id/deface', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        if(!session) return next("no such session");

        fs.writeFile(process.env.WORK_DIR + "/"+session._id+"/deface.json", JSON.stringify(req.body), err=>{
            session.status = "deface";
            session.status_msg = "Waiting to be defaced";
            session.save().then(()=>{
                res.send("ok");
            });
        });
    });
});

router.post('/session/:session_id/canceldeface', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        if(!session) return next("no such session");

        //request deface.cancel by writing out "deface.cancel" file
        console.debug("writing .cancel");
        fs.writeFile(process.env.WORK_DIR + "/"+session._id+"/.cancel", "", err=>{
            if(err) console.error(err);

            session.status_msg = "requested to cancel defacing";

            //handler should set the status when the job is killed so this shouldn't
            //be necessary.. but right not kill() doesn't work.. so
            session.deface_begin_date = undefined;
            session.status = "analyzed";
            session.save().then(()=>{
                res.send("ok");
            });
        });
    });
});

router.post('/session/:session_id/resetdeface', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        if(!session) return next("no such session");
        try {
            const workdir = process.env.WORK_DIR + "/"+session._id;
            console.log("removing deface output");
            if(fs.existsSync(workdir+"/deface.finished")) {
                fs.unlinkSync(workdir+"/deface.finished");
            }
            if(fs.existsSync(workdir+"/deface.failed")) {
                fs.unlinkSync(workdir+"/deface.failed");
            }
            session.status = "analyzed";
            session.status_msg = "reset defacing";
            session.deface_begin_date = undefined;
            session.deface_finish_date = undefined;
            session.save().then(()=>{
                res.send("ok");
            });
        } catch (err) {
            console.error(err);
            res.send(err);
        }
    });
});

router.post('/session/:session_id/finalize', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        if(!session) return next("no such session");
        fs.writeFile(process.env.WORK_DIR + "/"+session._id+"/finalized.json", JSON.stringify(req.body), err=>{
            models.ezBIDS.findOneAndUpdate({_session_id: req.params.session_id}, {$set: {

                //TODO - store this somewhere for book keeping
                //updated: req.body, //finalized.json could exceed 16MB 

                update_date: new Date(),
            }}).then(err=>{
                session.status = "finalized";
                session.status_msg = "Waiting to be finalized";
                session.save().then(()=>{
                    res.send("ok");
                });
            });
        });
    });
});

//download finalized(updated) content
router.get('/session/:session_id/updated', (req, res, next)=>{
    models.ezBIDS.findOne({_session_id: req.params.session_id}).then(ezbids=>{
        if(!ezbids) return next("no such session or ezbids not finalized");
        if(!ezbids.updated) return next("not yet finalized");
        res.json(ezbids.updated);
    });
});

//let user download files within session (like the .png image generated by analyzer)
router.get('/download/:session_id/*', (req, res, next)=>{
    models.Session.findById(req.params.session_id).then(session=>{
        const basepath = process.env.WORK_DIR + "/"+session._id;

        //validate path so it will be inside the basepath
        const fullpath = path.resolve(basepath+"/"+req.params[0]);
        if(!fullpath.startsWith(basepath)) return next("invalid path");

        //TODO - if requested path is a file, thenstream
        const stats = fs.lstatSync(fullpath);
        if(stats.isFile()) {
            res.setHeader('Content-disposition', 'attachment; filename='+path.basename(fullpath));
            fs.createReadStream(fullpath).pipe(res);
        } else if(stats.isDirectory()) {
            res.setHeader('Content-disposition', 'attachment; filename='+path.basename(fullpath)+".zip");
            const archive = archiver('zip', {
                zlib: { level: 0 }
            });
            archive.directory(fullpath, 'bids');
            archive.finalize();
            archive.pipe(res);

        } else next("weird file");
    }).catch(err=>{
        next(err);
    });
});

router.post('/upload-multi/:session_id', upload.any(), (req:any, res, next)=>{

    //when a single file is uploaded paths becomes just a string. convert it to an array of 1
    let paths = req.body["paths"];
    if(!Array.isArray(paths)) paths = [paths];
    //same for mtimes
    let mtimes = req.body["mtimes"];
    if(!Array.isArray(mtimes)) mtimes = [mtimes];

    models.Session.findById(req.params.session_id).then(async session=>{
        let idx = -1;
        async.eachSeries(req.files, (file, next_file)=>{
            idx++;
            const src_path = file.path;
            /* //file
11|ezbids- | {
11|ezbids- |   fieldname: 'files',
11|ezbids- |   originalname: 'i1848324.MRDC.82',
11|ezbids- |   encoding: '7bit',
11|ezbids- |   mimetype: 'application/octet-stream',
11|ezbids- |   destination: '/mnt/ezbids/upload',
11|ezbids- |   filename: '2d682c5694b0fb8da2beeea3e670350a',
11|ezbids- |   path: '/mnt/ezbids/upload/2d682c5694b0fb8da2beeea3e670350a',
11|ezbids- |   size: 147882
11|ezbids- | }
            */
            const dirty_path = process.env.WORK_DIR + "/"+req.params.session_id+"/"+paths[idx];
            const dest_path = path.resolve(dirty_path);
            const mtime = mtimes[idx]/1000; //browser uses msec.. filesystem uses sec since epoch

            if(!dest_path.startsWith(process.env.WORK_DIR ) ) return next_file("invalid path:", dest_path);
            const destdir = path.dirname(dest_path);

            //move the file over to workdir
            const made = mkdirp.sync(destdir);
            fs.renameSync(src_path, dest_path);
            if(mtime) fs.utimesSync(dest_path, mtime, mtime);
            next_file();
        }, err=>{
            if(err) return next(err);
            res.send("ok");
        });

    }).catch(err=>{
        console.error(err);
        next(err);
    });
});

//done uploading.
router.patch('/session/uploaded/:session_id', (req, res, next)=>{
    models.Session.findByIdAndUpdate(req.params.session_id, {
        status: "uploaded",
        status_msg: "Waiting in the queue..",
        upload_finish_date: new Date()
    }).then(session=>{
        if(!session) return next("no such session");
        res.send("ok");
    }).catch(err=>{
        console.error(err);
        next(err);
    });
});

module.exports = router;

